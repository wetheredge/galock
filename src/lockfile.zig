const std = @import("std");

const toml = @import("toml");

const LockfileV0 = struct {
    action: []Action = &.{},
};

pub const Action = struct {
    repo: []const u8,
    tag: []const u8,
    commit: []const u8,
};

const header =
    \\# This file is automatically @generated by galok.
    \\# https://tangled.sh/wetheredge.com/galok
    \\# It is not intended for manual editing.
    \\
;
const version_prefix = "version = ";

pub const Wrapper = struct {
    path: []const u8,
    arena: ?std.heap.ArenaAllocator = null,
    actions: std.ArrayList(Action) = .empty,

    pub fn get(self: *const Wrapper, action: []const u8) ?*const Action {
        switch (self.findActionIndex(action)) {
            .found => |i| return &self.actions.items[i],
            .missing => return null,
        }
    }

    pub fn set(
        self: *Wrapper,
        allocator: std.mem.Allocator,
        action: []const u8,
        tag: []const u8,
        commit: []const u8,
    ) !?[]const u8 {
        switch (self.findActionIndex(action)) {
            .found => |i| {
                var found = &self.actions.items[i];
                const old = found.tag;
                found.tag = tag;
                found.commit = commit;
                return old;
            },
            .missing => |i| {
                try self.actions.insert(allocator, i, .{
                    .repo = action,
                    .tag = tag,
                    .commit = commit,
                });

                return null;
            },
        }
    }

    pub fn remove(self: *Wrapper, action: []const u8) ?[]const u8 {
        switch (self.findActionIndex(action)) {
            .found => |i| {
                const tag = self.actions.items[i].tag;

                const new_len = self.actions.items.len - 1;
                @memmove(
                    self.actions.items[i..new_len],
                    self.actions.items[(i + 1)..],
                );
                self.actions.shrinkRetainingCapacity(new_len);

                return tag;
            },
            .missing => return null,
        }
    }

    const FindResult = union(enum) {
        found: usize,
        missing: usize,
    };

    fn findActionIndex(self: *const Wrapper, action: []const u8) FindResult {
        // Based on std.sort.binarySearch
        var low: usize = 0;
        var high: usize = self.actions.items.len;

        while (low < high) {
            const mid = low + (high - low) / 2;
            switch (std.mem.order(u8, action, self.actions.items[mid].repo)) {
                .eq => return .{ .found = mid },
                .lt => high = mid,
                .gt => low = mid + 1,
            }
        }

        return .{ .missing = high };
    }

    pub fn write(self: *Wrapper) !void {
        const file = try std.fs.cwd().createFile(self.path, .{});
        defer file.close();

        var buf: [4096]u8 = undefined;
        var w = file.writer(&buf);

        var header_vec: [3][]const u8 = .{ header, version_prefix, "0\n" };
        try w.interface.writeVecAll(&header_vec);

        for (self.actions.items) |action| {
            var action_vec: [7][]const u8 = .{
                "\n[[action]]\nrepo = \"",
                action.repo,
                "\"\ntag = \"",
                action.tag,
                "\"\ncommit = \"",
                action.commit,
                "\"\n",
            };
            try w.interface.writeVecAll(&action_vec);
        }

        try w.end();
    }

    pub fn deinit(self: *Wrapper, allocator: std.mem.Allocator) void {
        self.actions.deinit(allocator);
        if (self.arena) |alloc| alloc.deinit();
    }
};

pub fn fromPath(allocator: std.mem.Allocator, path: []const u8) !Wrapper {
    var self = Wrapper{
        .path = path,
    };

    const file = std.fs.cwd().openFile(path, .{}) catch |err| {
        if (err == error.FileNotFound) {
            return self;
        } else {
            return err;
        }
    };
    defer file.close();

    var buf: [4096]u8 = undefined;
    var r = file.reader(&buf);
    var w = std.io.Writer.Allocating.init(allocator);
    defer w.deinit();

    var version: u8 = undefined;
    while (true) {
        _ = try r.interface.streamDelimiter(&w.writer, '\n');
        _ = try r.interface.takeByte();

        const line = std.mem.trimStart(u8, w.written(), " \t");
        if (line.len == 0 or std.mem.startsWith(u8, line, "#")) {
            _ = w.writer.consumeAll();
            continue;
        }

        if (std.mem.startsWith(u8, line, "version = ")) {
            const raw = line[version_prefix.len..];
            version = std.fmt.parseInt(u8, raw, 10) catch return error.MalformedVersion;
            _ = w.writer.consumeAll();
            break;
        } else {
            return error.MissingVersion;
        }
    }

    if (version != 0) {
        return error.InvalidVersion;
    }

    _ = try r.interface.streamRemaining(&w.writer);
    const contents = w.written();

    var parser = toml.Parser(LockfileV0).init(allocator);
    defer parser.deinit();

    const result = try parser.parseString(contents);
    self.arena = result.arena;
    try self.actions.appendSlice(allocator, result.value.action);

    return self;
}
